# C++序列式容器（STL 序列式容器）是什么

序列容器以线性序列的方式存储元素。它没有对元素进行排序，元素的顺序和存储它们的顺序相同。以下有 5 种标准的序列容器，每种容器都具有不同的特性：

*   array<T,N>(数组容器)是一个长度固定的序列，有 N 个 T 类型的对象，不能增加或删除元素。
*   vector<T>(向量容器)是一个长度可变的序列，用来存放 T 类型的对象。必要时，可以自动增加容量，但只能在序列的末尾高效地增加或删除元素。
*   deque<T>(双向队列容器)是一个长度可变的、可以自动增长的序列，在序列的两端都不能高效地增加或删除元素。
*   list<T>(链表容器)是一个长度可变的、由 T 类型对象组成的序列，它以双向链表的形式组织元素，在这个序列的任何地方都可以高效地增加或删除元素。访问容器中任意元素的速度要比前三种容器慢，这是因为 list<T> 必须从第一个元素或最后一个元素开始访问，需要沿着链表移动，直到到达想要的元素。
*   forward list<T>(正向链表容器)是一个长度可变的、由 T 类型对象组成的序列，它以单链表的形式组织元素，是一类比链表容器快、更节省内存的容器，但是它内部的元素只能从第一个元素开始访问。

图 1 说明了可供使用的序列容器以及它们之间的区别。
![](img/01955674044196bc2b29028da23709fa.jpg)
图 1 标准的序列容器
图 1 中每种类型容器的操作都可以高效执行，但其他示例中的操作可能会慢一些。

## 容器中常见的函数成员

在本章的剩余部分，会详细介绍每一类序列容器的用法。序列容器包含一些相同的成员函数，它们的功能也相同。本教程会在某个容器的上下文中详细介绍下面的每个函数，但对于每种类型的容器不会重复介绍它们的细节。

表 2 展示了 array、vector 和 deque 容器的函数成员，它们中至少有两个容器实现了同样的函数成员。

表 2 array、vector 和 deque 容器的函数成员

| 函数成员 | array<T,N> | vector<T> | deque<T> |
| begin() - 返回幵始迭代器 | 是 | 是 | 是 |
| end() - 返回结束迭代器 | 是 | 是 | 是 |
| rbegin() - 返回反向'开始迭代器 | 是 | 是 | 是 |
| rend() - 返回反向结束迭代器 | 是 | 是 | 是 |
| cbegin() - 返 M const 开始迭代器 | 是 | 是 | 是 |
| cend() - 返回 const 结束迭代器 | 是 | 是 | 是 |
| crbegin() - 返回 const 反向开始迭代器 | 是 | 是 | 是 |
| crend() - 返回 const 反向结束迭代器 | 是 | 是 | 是 |
| assign() - 用新元素替换原有内容 | - | 是 | 是 |
| operator=() - 复制同类型容器的元素，或者用初始化列表替换 现有内容 | 是 | 是 | 是 |
| size() - 返回实际元素个数 | 是 | 是 | 是 |
| max_size() - 返回元素个数的设大值 | 是 | 是 | 是 |
| capacity() - 返回当前容量 | - | 是 | - |
| empty() - 返回 true,如果容器中没有元素的话 | 是 | 是 | 是 |
| resize() - 改变实际元素的个数 | - | 是 | 是 |
| shrink _to_fit() - 将内存减少到等于当前元素实际所使用的大小 | - | 是 | 是 |
| front() - 返回第一个元素的引用 | 是 | 是 | 是 |
| back() - 返回铖后一个元素的引用 | 是 | 是 | 是 |
| operator[]() - 使用索弓丨访问元素 | 是 | 是 | 是 |
| at() - 使用经过边界检査的索引访问元素 | 是 | 是 | 是 |
| push_back() - 在序列的尾部添加一个元素 | - | 是 | 是 |
| insert() - 在指定的位置插入一个或多个元素 | - | 是 | 是 |
| emplace() - 在指定的位置直接生成一个元素 | - | 是 | 是 |
| emplace_back() - 在序列尾部生成一个元素 | - | 是 | 是 |
| pop_back() - 移出序列尾部的元素 | - | 是 | 是 |
| erase() - 移出一个元素或一段元素 | - | 是 | 是 |
| clear() - 移出所苻的元素，容器大小变为 0 | - | 是 | 是 |
| swap() - 交换两个容器的所有元素 | 是 | 是 | 是 |
| data() - 返回包含元素的内部数组的指针 | 是 | 是 | - |

缺少“是”的列表明，对应的容器并没有定义这个函数。没有必要记住这张表，该表仅供参考。在深入了解到容器是如何组织元素以后，你会本能地知道哪个容器的哪些成员函数能使用。

在表 2 中，对于以链表来组织元素的容器，它们的内部组织方式有很大差别。list 和 forward_list 容器彼此非常相似。forward_list 中包含了 list 的大部分成员函数，forward_list 中未包含那些需要反向遍历的函数，所以示例中没有反向迭代器。作为参考，表 3 展示了 list 和 forward_list 的函数成员。

表 3 list 和 forward_list 的函数成员

| 函数成员 | list<T> | forward list<T> |
| begin() - 返回开始迭代器 | 是 | 是 |
| end() - 返回结束迭代器 | 是 | 是 |
| rbegin() - 返回反向开始迭代器 | 是 | - |
| rend() - 返回反向结束迭代器 | 是 | - |
| cbegin() - 返回 const 开始结束迭代器 | 是 | 是 |
| before_begin() - 返回一个指向第一个元素前一个位置的迭代器 | - | 是 |
| cbefore_begin() - 返回一个指向第一个元素前一个位置的 const 迭代器 | - | 是 |
| cend() - 返回 const 结束迭代器 | 是 | 是 |
| crbegin() - 返回 const 反向开始迭代器 | 是 | - |
| crend() - 返回 const 反向结束迭代器 | 是 | - |
| assign() - 用新元素替换原有内容 | 是 | 是 |
| operator=() - 复制同类型容器的元素，或者用初始化列表替换现有内容 | 是 | 是 |
| size() - 返回实际元素个数 | 是 | - |
| max_size() - 返回元素个数的最大值 | 是 | 是 |
| resize() - 改变实际元素的个数 | 是 | 是 |
| empty() - 返回 true，如果容器中没有元素的话 | 是 | 是 |
| from() - 返回第一个元素的引用 | 是 | 是 |
| back() - 返回最后一个元素的引用 | 是 | - |
| push_back() - 在序列的潘部添加一个元素 | 是 | - |
| push_front() - 在序列的起始位置添加一个元素 | 是 | 是 |
| emplace() - 在指矩位置直接生成一个元素 | 是 | - |
| emplace_after() - 在指定位置的后面直接生成一个元素 | - | 是 |
| emplace_back() - 在序列尾部生成一个元素 | 是 | - |
| cmplacc_front() - 在序列的起始位生成一个元索 | 是 | 是 |
| insert() - 在指定的位置插入一个或多个元素 | 是 | - |
| insert_after() - 在指定位置的后面插入一个或多个元素 | - | 是 |
| pop_back() - 移除序列尾部的元素 | 是 | - |
| pop_front() - 移除序列头部的元素 | 是 | 是 |
| reverse()-反向元素的顺序 | 是 | 是 |
| erase() - 移除指定位置的一个元素或一段元素 | 是 | - |
| erase_after() - 移除指定位 1；后面的一个元素或一段元素 | - | 是 |
| remove() - 移除所苻和参数匹配的元素 | 是 | 是 |
| remove_if() - 移除满足一元函数条件的所有元素 | 是 | 是 |
| unique() - 移除所有连续重复的元素 | 是 | 是 |
| clear() - 移除所有的元素，容器大小变为 0 | 是 | 是 |
| swap() - 交换两个容器的所有元素 | 是 | 是 |
| sort() - 对元素进行排序 | 是 | 是 |
| merge() - 合并两个有序容器 | 是 | 是 |
| splice() - 移动指定位置前面的所有元素到另一个同类型的 list 中 | 是 | - |
| splice_after() - 移动指定位置后面的所有元素到另一个同类型的 list 中 | - | 是 |

所有序列容器的函数成员 max_size() 都会返回它能存储的元素个数的最大值。这通常是一个很大的值，一般是 2³²-1,所以我们很少会用到这个函数。