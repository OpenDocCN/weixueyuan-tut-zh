# C++ move(STL move)函数使用详解

move() 算法会将它的前两个输入迭代器参数指定的序列移到第三个参数定义的目的序列的开始位置，第三个参数必须是输出迭代器。这个算法返回的迭代器指向最后一个被移动到目的序列的元素的下一个位置。

这是一个移动操作，因此无法保证在进行这个操作之后，输入序列仍然保持不变；源元素仍然会存在，但它们的值可能不再相同了，因此在移动之后，就不应该再使用它们。如果源序列可以被替换或破坏，就可以选择使用 move() 算法。如果不想扰乱源序列，可以使用 copy() 算法。下面是一个展示如何使用它的示例：

```
std::vector<int> srce {1, 2, 3, 4};
std::deque<int> dest {5, 6, 7, 8};
std::move(std::begin(srce), std::end(srce), std::back_inserter(dest));
```

这里会将 data 的最后 6 个元素移到容器的开头。它能够正常工作是因为目的地址在源序列之外。在移动之后，无法保证最后两个元素的值。这里它们虽然被移除了，但同样可以将它们重置为已知的值一一例如 0。

最后一行中的注释展示了输出结果。当然也可以用 rotate() 算法来代替 move() 移动元素，在这种情况下，我们肯定知道最后两个元素的值。

如果一个移动操作的目的地址位于源序列之内，move() 就无法正常工作，这意味着移动需要从序列的右边开始。原因是一些元素在移动之前会被重写，但 move_backward() 可以正常工作。它的前两个参数指定了被移动的序列，第三个参数是目的地址的结束迭代器。例如：

```
std::vector<int> data {1, 2, 3, 4, 5, 6, 7, 8};
std::move(std::begin(data) + 2, std::end(data), std::begin(data));
data.erase(std::end(data) - 2, std::end(data)); // Erase moved elements
std::copy(std::begin (data), std::end(data), std::ostream_iterator<int> {std::cout, " "});
std::cout << std::endl;
// 3, 4, 5, 6, 7, 8
```

这里使用 deque 容器只是为了换个容器使用。将前 6 个元素向右移动两个位置。在移动操作后，值无法得到保证的元素会被重置为 0。最后一行展示了这个操作的结果。