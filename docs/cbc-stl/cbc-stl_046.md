# 第四章 map 容器

序列容器是管理数据的宝贵工具，但对大多数应用程序而言，序列容器不提供方便的数据访问机制。举个简单的示例，当我们用它处理姓名和地址时，在这种场景下，序列容器可能并不能如我们所愿。一种典型的方法是通过名称来寻找地址。如果记录保存在序列容器中，就只能通过搜索得到这些数据。相比而言，map 容器提供了一种更有效的存储和访问数据的方法。

map 容器是关联容器的一种。在关联容器中，对象的位置取决于和它关联的键的值。键可以是基本类型，也可以是类类型。字符串经常被用来作为键，如果想要保存姓名和地址的记录，就可以这么使用。名称通常可能是一个或多个字符串。关联容器中的对象位置的确定取决于容器中的键的类型，而且对于特定容器类型的内部组织方式，不同的 STL 有不同的实现。

map 容器有 4 种，每一种都是由类模板定义的。所有类型的 map 容器保存的都是键值对类型的元素。map 容器的元素是 pair<const K，T> 类型的对象，这种对象封装了一个 T 类型的对象和一个与其关联的 K 类型的键。pair 元素中的键是 const，因为修改键会扰乱容器中元素的顺序。每种 map 容器的模板都有不同的特性：

1.  map<K，T>容器，保存的是 pair<const K，T> 类型的元素。pair<const K,T> 封装了一对键对象，键的类型是 K，对象的类型是 T。每个键都是唯一的，所以不允许有重复的键；但可以保存重复的对象，只要它们的键不同。map 容器中的元素都是有序的，元素在容器内的顺序是通过比较键确定的。默认使用 less<K> 对象比较。
2.  multimap<K，T> 容器和 map<K，T> 容器类似，也会对元素排序。它的键必须是可比较的，元素的顺序是通过比较键确定的。和 map<K，T> 不同的是，multimap<K，T> 允许使用重复的键。因此，一个 multimap 容器可以保存多个具有相同键值的 <const K,T> 元素。
3.  unordered_map<K，T> 中 pair< const K，T>元素的顺序并不是直接由键值确定的，而是由键值的哈希值决定的。哈希值是由一个叫作哈希的过程生成的整数，本章后面会解释这一点。unordered_map<K，T>不允许有重复的键。
4.  unordered_multimap<K,T> 也可以通过键值生成的哈希值来确定对象的位置，但它允许有重复的键。

map 和 mutilmap 容器的模板定义在 map 头文件中，unordered_map 和 unordered_multimap 容器的模板定义在 unordered_map 头文件中。可以通过 map 模板类型名的前缀来识别容器的特性。

*   multi 前缀表明键不必唯一，但如果没有这个前缀，键必须唯一。
*   unordered_prefix 前缀表明容器中元素的位置是通过其键值所产生的哈希值来决定的，而不是通过比较键值决定的。如果没有该前缀，那么元素的位置就由比较键值决定。

接下来让我们先学习 map 容器。