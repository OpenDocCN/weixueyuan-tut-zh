# Go 语言并发打印（借助通道实现）

前面的例子创建的都是无缓冲通道。使用无缓冲通道往里面装入数据时，装入方将被阻塞，直到另外通道在另外一个 goroutine 中被取出。同样，如果通道中没有放入任何数据，接收方试图从通道中获取数据时，同样也是阻塞。发送和接收的操作是同步完成的。

下面通过一个并发打印的例子，将 goroutine 和 channel 放在一起展示它们的用法。

```
package main

import (
    "fmt"
)

func printer(c chan int) {

    // 开始无限循环等待数据
    for {

        // 从 channel 中获取一个数据
        data := <-c

        // 将 0 视为数据结束
        if data == 0 {
            break
        }

        // 打印数据
        fmt.Println(data)
    }

    // 通知 main 已经结束循环(我搞定了!)
    c <- 0

}

func main() {

    // 创建一个 channel
    c := make(chan int)

    // 并发执行 printer, 传入 channel
    go printer(c)

    for i := 1; i <= 10; i++ {

        // 将数据通过 channel 投送给 printer
        c <- i
    }

    // 通知并发的 printer 结束循环(没数据啦!)
    c <- 0

    // 等待 printer 结束(搞定喊我!)
    <-c

}
```

运行代码，输出如下：
1
2
3
4
5
6
7
8
9
10

代码说明如下：

*   第 10 行，创建一个无限循环，只有当第 16 行获取到的数据为 0 时才会退出循环。
*   第 13 行，从函数参数传入的通道中获取一个整型数值。
*   第 21 行，打印整型数值。
*   第 25 行，在退出循环时，通过通道通知 main() 函数已经完成工作。
*   第 32 行，创建一个整型通道进行跨 goroutine 的通信。
*   第 35 行，创建一个 goroutine，并发执行 printer() 函数。
*   第 37 行，构建一个数值循环，将 1～10 的数通过通道传送给 printer 构造出的 goroutine。
*   第 44 行，给通道传入一个 0，表示将前面的数据处理完成后，退出循环。
*   第 47 行，在数据发送过去后，因为并发和调度的原因，任务会并发执行。这里需要等待 printer 的第 25 行返回数据后，才可以退出 main()。

本例的设计模式就是典型的生产者和消费者。生产者是第 37 行的循环，而消费者是 printer() 函数。整个例子使用了两个 goroutine，一个是 main()，一个是通过第 35 行 printer() 函数创建的 goroutine。两个 goroutine 通过第 32 行创建的通道进行通信。这个通道有下面两重功能。

*   数据传送：第 40 行中发送数据和第 13 行接收数据。
*   控制指令：类似于信号量的功能。同步 goroutine 的操作。功能简单描述为：
    *   第 44 行：“没数据啦！”
    *   第 25 行：“我搞定了！”
    *   第 47 行：“搞定喊我！”