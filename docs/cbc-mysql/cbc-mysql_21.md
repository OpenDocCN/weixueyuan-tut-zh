# Mysql 锁的优化

## 获取锁等待情况

可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁定争夺：
mysql> show status like 'Table%';
+----------------------------+----------+
| Variable_name       | Value |
+----------------------------+----------+
| Table_locks_immediate   | 105       |
| Table_locks_waited  | 3     |
+----------------------------+----------+
2 rows in set (0.00 sec)

可以通过检查 Innodb_row_lock 状态变量来分析系统上的行锁的争夺情况：
mysql> show status like 'innodb_row_lock%';
+----------------------------------------+----------+
| Variable_name               | Value |
+----------------------------------------+----------+
| Innodb_row_lock_current_waits   | 0     |
| Innodb_row_lock_time            | 2001  |
| Innodb_row_lock_time_avg        | 667       |
| Innodb_row_lock_time_max    | 845       |
| Innodb_row_lock_waits       | 3     |
+----------------------------------------+----------+
5 rows in set (0.00 sec)

另外，针对 Innodb 类型的表，如果需要察看当前的锁等待情况，可以设置 InnoDB Monitors，然后通过 Show innodb status 察看，设置的方式是：
    CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB;
监视器可以通过发出下列语句来被停止：
    DROP TABLE innodb_monitor;
设置监视器后，在 show innodb status 的显示内容中，会有详细的当前锁等待的信息，包括表名、锁类型、锁定记录的情况等等，便于进行进一步的分析和问题的确定。打开监视器以后，默认情况下每 15 秒会向日志中记录监控的内容，如果长时间打开会导致.err 文件变得非常的巨大，所以我们在确认问题原因之后，要记得删除监控表以关闭监视器。或者通过使用--console 选项来启动服务器以关闭写日志文件。

## 什么情况下使用表锁

**表级锁在下列几种情况下比行级锁更优越：**

1.  很多操作都是读表。
2.  在严格条件的索引上读取和更新，当更新或者删除可以用单独的索引来读取得到时：
3.  UPDATE tbl_name SET column=value WHERE unique_key_col=key_value;
4.  DELETE FROM tbl_name WHERE unique_key_col=key_value;
5.  SELECT 和 INSERT 语句并发的执行，但是只有很少的 UPDATE 和 DELETE 语句。
6.  很多的扫描表和对全表的 GROUP BY 操作，但是没有任何写表。

## 什么情况下使用行锁

**行级锁定的优点：**

1.  当在许多线程中访问不同的行时只存在少量锁定冲突。
2.  回滚时只有少量的更改。
3.  可以长时间锁定单一的行。

**行级锁定的缺点：**

1.  比页级或表级锁定占用更多的内存。
2.  当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。
3.  如果你在大部分数据上经常进行 GROUP BY 操作或者必须经常扫描整个表，比其它锁定明显慢很多。
4.  用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁成本小于行级锁定。

## insert …select …带来的问题

当使用 insert...select...进行记录的插入时，如果 select 的表是 innodb 类型的，不论 insert 的表是什么类型的表，都会对 select 的表的纪录进行锁定。

对于那些从 oracle 迁移过来的应用，需要特别的注意，因为 oracle 并不存在类似的问题，所以在 oracle 的应用中 insert...select...操作非常的常见。例如：有时候会对比较多的纪录进行统计分析，然后将统计的中间结果插入到另外一个表，这样的操作因为进行的非常少，所以可能并没有设置相应的索引。如果迁移到 mysql 数据库后不进行相应的调整，那么在进行这个操作期间，对需要 select 的表实际上是进行的全表扫描导致的所有记录的锁定，将会对应用的其他操作造成非常严重的影响。

究其主要原因，是因为 mysql 在实现复制的机制时和 oracle 是不同的，如果不进行 select 表的锁定，则可能造成从数据库在恢复期间插入结果集的不同，造成主从数据的不一致。如果不采用主从复制，关闭 binlog 并不能避免对 select 纪录的锁定，某些文档中提到可以通过设置 innodb_locks_unsafe_for_binlog 来避免这个现象，当这个参数设置为 true 的时候，将不会对 select 的结果集加锁，但是这样的设置将可能带来非常严重的隐患。如果使用这个 binlog 进行从数据库的恢复，或者进行主数据库的灾难恢复，都将可能和主数据库的执行效果不同。

因此，我们并不推荐通过设置这个参数来避免 insert...select...导致的锁，如果需要进行可能会扫描大量数据的 insert...select 操作，我们推荐使用 select...into outfile 和 load data infile 的组合来实现，这样是不会对纪录进行锁定的。

## next-key 锁对并发插入的影响

在行级锁定中，InnoDB 使用一个名为 next-key locking 的算法。InnoDB 以这样一种方式执行行级锁定：当它搜索或扫描表的索引之时，它对遇到的索引记录设置共享或独占锁定。因此，行级锁定事实上是索引记录锁定。

InnoDB 对索引记录设置的锁定也映像索引记录之前的“间隙”。如果一个用户对一个索引上的记录 R 有共享或独占的锁定，另一个用户 不能紧接在 R 之前以索引的顺序插入一个新索引记录。这个间隙的锁定被执行来防止所谓的“幽灵问题”。

可以用 next-key 锁定在你的应用程序上实现一个唯一性检查：如果你以共享模式读数据，并且没有看到你将要插入的行的重复，则你可以安全地插入你的行，并且知道在读过程中对你的行的继承者设置的 next-key 锁定与此同时阻止任何人对你的行插入一个重复。因此，the next-key 锁定允许你锁住在你的表中并不存在的一些东西。

## 隔离级别对并发插入的影响

REPEATABLE READ 是 InnoDB 的默认隔离级别。带唯一搜索条件使用唯一索引的 SELECT ... FOR UPDATE, SELECT ... LOCK IN SHARE MODE, UPDATE 和 DELETE 语句只锁定找到的索引记录，而不锁定记录前的间隙。用其它搜索条件，这些操作采用 next-key 锁定，用 next-key 锁定或者间隙锁定锁住搜索的索引范围，并且阻止其它用户的新插入。

在持续读中，有一个与 READ COMMITTED 隔离级别重要的差别：在这个级别，在同一事务内所有持续读读取由第一次读所确定的同一快照。这个惯例意味着如果你在同一事务内发出数个无格式 SELECT 语句，这些 SELECT 语句对相互之间也是持续的。

READ COMMITTED 隔离级别是一个有些象 Oracle 的隔离级别。所有 SELECT ... FOR UPDATE 和 SELECT ... LOCK IN SHARE MOD 语句仅锁定索引记录，而不锁定记录前的间隙，因而允许随意紧挨着已锁定的记录插入新记录。UPDATE 和 DELETE 语句使用一个带唯一搜索条件的唯一的索引仅锁定找到的索引记录，而不包括记录前的间隙。

在范围类型 UPDATE 和 DELETE 语句，InnoDB 必须对范围覆盖的间隙设置 next-key 锁定或间隙锁定以及其它用户做的块插入。这是很必要的，因为要让 MySQL 复制和恢复起作用，“幽灵行”必须被阻止掉。

如果应用是从基于 ORACLE 的应用迁移到 MYSQL 数据库的，那么建议使用该隔离级别提供数据库服务，因为该隔离级别是最接近 ORACLE 的默认隔离级别的，迁移可能遇到的锁问题最小。

## 如何减少锁冲突

**对 Myisam 类型的表：**
1) Myisam 类型的表可以考虑通过改成 Innodb 类型的表来减少锁冲突。

2) 根据应用的情况，尝试横向拆分成多个表或者改成 Myisam 分区对减少锁冲突也会有一定的帮助。

**对 Innodb 类型的表：**
1) 首先要确认，在对表获取行锁的时候，要尽量的使用索引检索纪录，如果没有使用索引访问，那么即便你只是要更新其中的一行纪录，也是全表锁定的。要确保 sql 是使用索引来访问纪录的，必要的时候，请使用 explain 检查 sql 的执行计划，判断是否按照预期使用了索引。

2) 由于 mysql 的行锁是针对索引加的锁，不是针对纪录加的锁，所以虽然是访问不同行的纪录，但是如果是相同的索引键，是会被加锁的。应用设计的时候也要注意，这里和 Oracle 有比较大的不同。

3) 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，当表有主键或者唯一索引的时候，不是必须使用主键或者唯一索引锁定纪录，其他普通索引同样可以用来检索纪录，并只锁定符合条件的行。

4) 用 SHOW INNODB STATUS 来确定最后一个死锁的原因。查询的结果中，包括死锁的事务的详细信息，包括执行的 SQL 语句的内容，每个线程已经获得了什么锁，在等待什么锁，以及最后是哪个线程被回滚。详细的分析死锁产生的原因，可以通过改进程序有效的避免死锁的产生。

5) 如果应用并不介意死锁的出现，那么可以在应用中对发现的死锁进行处理。

6) 确定更合理的事务大小，小事务更少地倾向于冲突。

7) 如果你正使用锁定读，（SELECT ... FOR UPDATE 或 ... LOCK IN SHARE MODE），试着用更低的隔离级别，比如 READ COMMITTED。

8) 以固定的顺序访问你的表和行。则事务形成良好定义的查询并且没有死锁。