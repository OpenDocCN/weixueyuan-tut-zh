# 文件的属性、基本操作以及文件的打开和关闭

## 文件的属性

文件有一定的属性，这根据系统的不同而有所不同，但是通常都包括如下属性：

①名称：文件名称唯一，以容易读取的形式保存。

②标识符：标识文件系统内文件的唯一标签,通常为数字，它是对人不可读的一种内部名称。

③类型：被支持不同类型的文件系统所使用。

④位置：指向设备和设备上文件的指针。

⑤大小：文件当前大小（用字节、字或块表示），也可包含文件允许的最大值。

⑥保护：对文件进行保护的访问控制信息。

⑦时间、日期和用户标识：文件创建、上次修改和上次访问的相关信息，用于保护、 安全和跟踪文件的使用。

所有文件的信息都保存在目录结构中，而目录结构也保存在外存上。文件信息当需要时再调入内存。通常，目录条目包括文件名称及其唯一标识符，而标识符定位其他属性的信息。

## 文件的基本橾作

文件属于抽象数据类型。为了恰当地定义文件，就需要考虑有关文件的操作。操作系统提供系统调用，它对文件进行创建、写、读、定位和截断。.

①创建文件：创建文件有两个必要步骤，一是在文件系统中为文件找到空间；二是在目录中为新文件创建条目，该条目记录文件名称、在文件系统中的位置及其他可能信息。

②写文件：为了写文件，执行一个系统调用，指明文件名称和要写入文件的内容。对于给定文件名称，系统搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作，便更新写指针。

③读文件：为了读文件，执行一个系统调用，指明文件名称和要读入文件块的内存位置。同样，需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于读和写操作都使用同一指针，节省了空间也降低了系统复杂度。

④文件重定位（文件寻址）：按某条件搜索目录，将当前文件位置设为给定值，并且不会读、写文件。

⑤删除文件：先从目录中找到要删除文件的目录项，使之成为空项，然后回收该文件所占用的存储空间。

⑥截断文件：允许文件所有属性不变，并删除文件内容，即将其长度设为 0 并释放其空间。

这 6 个基本操作可以组合执行其他文件操作。例如，一个文件的复制，可以创建新文件、 从旧文件读出并写入到新文件。

## 文件的打开与关闭

因为许多文件操作都涉及为给定文件搜索相关目录条目，许多系统要求在首次使用文件时，使用系统调用 open，将指明文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件目录表的一个表目中，并将该表目的编号（或称为索引）返回给用户。操作系统维护一个包含所有打开文件信息的表（打开文件表，open-file table）。当用户需要一个文件操作时，可通过该表的一个索引指定文件，就省略了搜索环节。当文件不再使用时，进程可以关闭它，操作系统从打开文件表中删除这一条目。

大部分操作系统要求在文件使用之前就被显式地打开。操作 open 会根据文件名搜索目录，并将目录条目复制到打开文件表。如果调用 open 的请求（创建、只读、读写、添加等）得到允许，进程就可以打开文件，而 open 通常返回一个指向打开文件表中的一个条目的指针。通过使用该指计（而非文件名）进行所有 I/O 操作，以简化步骤并节省资源。

整个系统表包含进程相关信息，如文件在磁盘的位置、访问日期和大小。一个进程打开一个文件，系统打开文件表就会为打开的文件增加相应的条目。当另一个进程执行 open 时，只不过是在其进程打开表中增加一个条目，并指向整个系统表的相应条目。通常，系统打开文件表的每个文件时，还用一个文件打开计数器(Open Count)，以记录多少进程打开了该文件。每个关闭操作 close 则使 count 递减，当打开计数器为 0 时，表示该文件不再被使用。系统将回收分配给该文件的内存空间等资源，若文件被修改过，则将文件写回外存，并将系统打开文件表中相应条目删除，最后释放文件的文件控制块(File Control Block, FCB)。

每个打开文件都有如下关联信息：

*   文件指针：系统跟踪上次读写位置作为当前文件位置指针，这种指针对打开文件的某个进程来说是唯一的，因此必须与磁盘文件属性分开保存。
*   文件打开计数：文件关闭时，操作系统必须重用其打开文件表条目，否则表内空间会不够用。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。该计数器跟踪打开和关闭的数量，当该计数为 0 时，系统关闭文件，删除该条目。
*   文件磁盘位置：绝大多数文件操作都要求系统修改文件数据。该信息保存在内存中以免为每个操作都从磁盘中读取。
*   访问权限：每个进程打开文件都需要有一个访问模式（创建、只读、读写、添加等)。该信息保存在进程的打开文件表中以便操作系统能允许或拒绝之后的 I/O 请求。