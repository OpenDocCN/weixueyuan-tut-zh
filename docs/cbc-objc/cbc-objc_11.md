# 类中 self 和“_”的使用

**对 self****的理解**

在使用 OC 语言创建一个类时，底层就为我们创建好了一个 self，它的使用范围仅限于在本类中（在类的实现部分）。

self 代表当前方法的调用者。在 OC 的类中，实现部分全部都是方法（声明部分无法使用 self），有类方法和对象方法。如果外界对象调用对象方法时，self 就代表这个对象；同样，调用类方法时，self 就代表这个类。

所以，这句话简单的理解，就是：如果 self 所在的这个方法是类方法，那么 self 就代表当前类；如果是对象方法，self 就代表当前类的对象。

在 self 表示本类对象的时候，就具备类对象的所有功能，可以使用 self 来调用类中的属性，例如：

self.name=@"ZhangSan";

当 self 表示本类的时候，可以用来调用其他类方法。

**对“­_****”的理解：**

对于在类内部的属性调用，OC 还提供了另外一种方式，就是我们之前看到的类似于“_name”的成员变量，由于我们声明的每个属性对应的都绑定着一个这样的成员变量，所以我们可以使用它来调用类中的属性。

而且使用 _name 还有另外一个好处，就是使用它调用这个属性的时候，不会调用这个属性的 set 或 get 方法。

可能你会问，既然它不会调用自己的 get 和 set 方法，用它干什么呢？

例如前面我们提到的，要对我们声明的属性进行重写它的 get 方法，方法的返回值就必须使用 _name。

如果使用 self.name 会出现什么情况呢？

我们前面讲过 self.name 会调用它的 set 方法或 get 方法。这样就会出现 get 方法中调用 get 方法或者是 set 方法中调用 set 方法，如此不断重复下去，造成死循环，程序将崩溃。所以在这种地方，我们就只能使用 _name 的这种形式。

可能有朋友会产生疑惑，那究竟什么时候用 _name，什么时候用 self.name 呢？

如果在编写过程中需要在类中调用本类的属性，如果这个地方必须调用 get 或 set 方法，那就必须使用 self.name 这种方式，如果在 get 或者 set 方法中，就必须使用 _name 的方式，如果不是上述的两种情况，使用哪个都可以。

**“super”关键字**

 在 OC 面向对象大环境下，不但提供有本类的 self，还有父类的 super 关键字。

super 和 self 的使用规则一样，不同之处在于：super 指父类方法的调用者。而 self 指当前方法的调用者。