# C 语言复合数据类型(结构体,共用体,枚举类型)

我们在前边学数据类型的时候，主要是字符型、整型、浮点型等基本类型，而学数组的时候，数组的定义要求数组元素必须是相同的数据类型。在实际应用中，有时候还需要把不同类型的数据组成一个有机的整体来处理，这些组合在一个整体中的数据之间还有一定的联系，比如一个学生的姓名、性别、年龄、考试成绩等，这就引入了复合数据类型。复合数据类型主要包含结构体数据类型、共用体数据类型和枚举体数据类型。

## 结构体数据类型

首先我们回顾一下上面的例程，我们把 DS1302 的 7 个字节的时间放到一个缓冲数组中，然后把数组中的值稍作转换显示到液晶上，这里就存在一个小问题，DS1302 时间寄存器的定义并不是我们常用的“年月日时分秒”的顺序，而是在中间加了一个字节的“星期几”，而且每当我要用这个时间的时候都要清楚的记得数组的第几个元素表示的是什么，这样一来，一是很容易出错，二是程序的可读性不强。当然你可以把每一个元素都定一个明确的变量名字，这样就不容易出错也易读了，但结构上却显得很零散了。于是，我们就可以用结构体来将这一组彼此相关的数据做一个封装，它们既组成了一个整体，易读不易错，而且可以单独定义其中每一个成员的数据类型，比如说把年份用 unsigned int 类型，即 4 个十进制位来表示显然比 2 位更符合日常习惯，而其它的类型还是可以用 2 位来表示。结构体本身不是一个基本的数据类型，而是构造的，它每个成员可以是一个基本的数据类型或者是一个构造类型。

结构体既然是一种构造而成的数据类型，那么在使用之前必须先定义它。

声明结构体变量的一般格式如下：

    struct  结构体名 {

        类型 1

        类型 2

        ……

        类型 n

        变量名 1;

        变量名 2;

        变量名 n;

    } 结构体变量名 1, 结构体变量名 2, ... 结构体变量名 n;

这种声明方式是在声明结构体类型的同时又用它定义了结构体变量，此时的结构体名是可以省略的，但如果省略后，就不能在别处再次定义这样的结构体变量了。这种方式把类型定义和变量定义混在了一起，降低了程序的灵活性和可读性，因此我们并不建议采用这种方式，而是推荐用以下这种方式：

    struct  结构体名 {

        类型 1  变量名 1；

        类型 2  变量名 2；

        ……

        类型 n  变量名 n；

    };

    struct  结构体名 结构体变量名 1, 结构体变量名 2, ... 结构体变量名 n;

为了方便大家理解，我们来构造一个实际的表示日期时间的结构体。

```
struct sTime { //日期时间结构体定义
    unsigned int year; //年
    unsigned char mon;  // 月
    unsigned char day;  // 日
    unsigned char hour; // 时
    unsigned char min; // 分
    unsigned char sec; // 秒
    unsigned char week;  // 星期
};
struct sTime bufTime;
```

struct 是结构体类型的关键字，sTime 是这个结构体的名字，bufTime 就是定义了一个具体的结构体变量。那如果要给结构体变量的成员赋值的话，写法是

    bufTime.year = 0x2013;

    bufTime.mon = 0x10;

数组的元素也可以是结构体类型，因此可以构成结构体数组，结构体数组的每一个元素都是具有相同结构类型的结构体变量。例如我们前边构造的这个结构类型，直接定义成 struct sTime bufTime[3];就表示定义了一个结构体数组，这个数组的 3 个元素，每一个都是一个结构体变量。同样的道理，结构体数组中的元素的成员如果需要赋值，就可以写成

    bufTime[0].year = 0x2013;

    bufTime[0].mon = 0x10;

一个指针变量如果指向了一个结构体变量的时候，称之为结构指针变量。结构指针变量是指向的结构体变量的首地址，通过结构体指针也可以访问到这个结构变量。

结构指针变量声明的一般形式如下：

    struct sTime *pbufTime;

这里要特别注意的是，使用结构体指针对结构体成员的访问，和使用结构体变量名对结构体成员的访问，其表达式有所不同。结构体指针对结构体成员的访问表达式为

    pbufTime->year = 0x2013;

或者是

    (*pbufTime).year = 0x2013;

很明显前者更简洁，所以推荐大家使用前者。

## 共用体数据类型

共用体也称之为联合体，共用体定义和结构体十分类似，我们同样是推荐以下形式：

     union 共用体名 {

        数据类型 1  成员名 1；

        数据类型 2  成员名 2；

        ……

        数据类型 n  成员名 n；

    };

    union 共用体名 共用体变量;

共用体表示的是几个变量共用一个内存位置，也就是成员 1、成员 2……成员 n 都用一个内存位置。共用体成员的访问方式和结构体是一样的，成员访问的方式是：共用体名.成员名，使用指针来访问的方式是：共用体名->成员名。

共用体可以出现在结构体内，结构体也可以出现在共用体内，在我们编程的日常应用中，最多应用是结构体出现在共用体内，例如：

```
union{
    unsigned int value;
    struct{
        unsigned char first;
        unsigned char second;
    } half;
} number;
```

这样将一个结构体定义到一个共用体内部，我们如果采用无符号整型赋值的时候，直接调用 value 这个变量，同时，我们也可以通过访问或赋值给 first 和 second 这两个变量来访问或修改 value 的高字节和低字节。

这样看起来似乎是可以高效率的在 int 型变量和它的高低字节之间切换访问，但请回想一下，我们在介绍数据指针的时候就曾提到过，多字节变量的字节序取决于单片机架构和编译器，并非是固定不变的，所以这种方式写好的程序代码在换到另一种单片机和编译环境后，就有可能是错的，从安全和可移植的角度来讲，这样的代码是存在隐患的，所以现在诸多以安全为首要诉求的 C 语言编程规范里干脆直接禁止使用共用体。我们虽然不禁止，但也不推荐你用，除非你清楚的了解你所使用的开发环境的实现细节。

共用体和结构体的主要区别如下：

*   结构体和共用体都是由多个不同的数据类型成员组成，但在任何一个时刻，共用体只能存放一个被选中的成员，而结构体所有的成员都存在。
*   对于共同体的不同成员的赋值，将会改变其它成员的值，而对于结构体不同成员的赋值是相互之间不影响的。

## 枚举数据类型

在实际问题中，有些变量的取值被限定在一个有限的范围内。例如，一个星期从周一到周日有 7 天，一年从 1 月到 12 月有 12 个月，蜂鸣器有响和不响两种状态等等。如果把这些变量定义成整型或者字符型不是很合适，因为这些变量都有自己的范围。C 语言提供了一种称为“枚举”的类型，在枚举类型的定义中列举出所有可能的值，并可以为每一个值取一个形象化的名字，它的这一特性可以提高程序代码的可读性。

枚举的说明形式如下：

    enum 枚举名{

        标识符 1[=整型常数],

        标识符 2[=整型常数],

        ……

        标识符 n[=整型常数]

    };

    enum 枚举名 枚举变量;

枚举的说明形式中，如果没有被初始化，那么“=整型常数”是可以被省略的，如果是默认值的话，从第一个标识符顺序赋值 0、1、2„„，但是当枚举中任何一个成员被赋值后，它后边的成员按照依次加 1 的规则确定数值。

枚举的使用，有几点要注意：

*   枚举中每个成员结束符是逗号，而不是分号，最后一个成员可以省略逗号。
*   枚举成员的初始化值可以是负数，但是后边的成员依然依次加 1。
*   枚举变量只能取枚举结构中的某个标识符常量，不可以在范围之外。