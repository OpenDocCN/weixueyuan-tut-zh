# 单片机数码管的静态显示

在第三章我们学习了 74HC138，了解到 74HC138 在同一时刻只能让一个输出口为低电平，也就是说在一个时刻内，我们只能使能一个数码管，并根据我们给出的 P0 的值来改变这个数码管的显示字符，我们可以将此理解为数码管的静态显示。

数码管静态显示是对应动态显示而言的，静态显示对于一两个数码管还行，多个数码管，静态显示实现的意义就没有了。这节课我们先用一个数码管的静态显示来实现一个简单的秒表，为下节课的动态显示打下基础。

先来介绍一个 51 单片机的关键字 code。我们前边课程定义变量的时候，一般用到 unsigned char 或者 unsigned int 这两个关键字，这样定义的变量都是放在我们的单片机的 RAM 中，我们在程序中可以随意去改变这些变量的值。但是还有一种数据，我们在程序中要使用，但是却不会改变它的值，定义这种数据时可以加一个 code 关键字修饰一下，这个数据就会存储到我们的程序空间 Flash 中，这样可以大大节省单片机的 RAM 的使用量，毕竟我们的单片机 RAM 空间比较小，而程序空间则大的多。那么现在要使用的数码管真值表，我们只会使用它们的值，而不需要改变它们，就可以用 code 关键字把它放入 Flash 中了，具体程序代码如下。

```
#include <reg52.h>

sbit ADDR0 = P1⁰;
sbit ADDR1 = P1¹;
sbit ADDR2 = P1²;
sbit ADDR3 = P1³;
sbit ENLED = P1⁴;

//用数组来存储数码管的真值表，数组将在下一章详细介绍
unsigned char code LedChar[] = {
    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
};

void main(){
    unsigned char cnt = 0;  //记录 T0 中断次数
    unsigned char sec = 0;  //记录经过的秒数

    ENLED = 0;  //使能 U3，选择数码管 DS1
    ADDR3 = 1;
    ADDR2 = 0;
    ADDR1 = 0;
    ADDR0 = 0;
    TMOD = 0x01;  //设置 T0 为模式 1
    TH0 = 0xB8;  //为 T0 赋初值 0xB800
    TL0 = 0x00;
    TR0 = 1;  //启动 T0

    while (1){
        if (TF0 == 1){  //判断 T0 是否溢出
            TF0 = 0;  //T0 溢出后，清零中断标志
            TH0 = 0xB8;  //并重新赋初值

            TL0 = 0x00;
            cnt++;  //计数值自加 1
            if (cnt >= 50){  //判断 T0 溢出是否达到 50 次
                cnt = 0;  //达到 50 次后计数值清零
                P0 = LedChar[sec]; //当前秒数对应的真值表中的值送到 P0 口
                sec++;  //秒数记录自加 1
                if (sec >= 16){  //当秒数超过 0x0F(15)后，重新从 0 开始
                   sec = 0;
                }
            }
        }
    }
}
```