# 单片机独立按键扫描程序

原理搞清楚了，那么下面我们就先编写一个独立按键的程序，把最基本的功能验证一下。

```
#include <reg52.h>

sbit ADDR0 = P1⁰;
sbit ADDR1 = P1¹;
sbit ADDR2 = P1²;
sbit ADDR3 = P1³;
sbit ENLED = P1⁴;
sbit LED9 = P0⁷;
sbit LED8 = P0⁶;
sbit LED7 = P0⁵;
sbit LED6 = P0⁴;
sbit KEY1 = P2⁴;
sbit KEY2 = P2⁵;
sbit KEY3 = P2⁶;
sbit KEY4 = P2⁷;

void main(){
    ENLED = 0;  //选择独立 LED 进行显示
    ADDR3 = 1;
    ADDR2 = 1;
    ADDR1 = 1;
    ADDR0 = 0;
    P2 = 0xF7;  //P2.3 置 0，即 KeyOut1 输出低电平

    while (1){
        //将按键扫描引脚的值传递到 LED 上
        LED9 = KEY1;  //按下时为 0，对应的 LED 点亮
        LED8 = KEY2;
        LED7 = KEY3;
        LED6 = KEY4;
    }
}
```

本程序固定在 KeyOut1 上输出低电平，而 KeyOut2～4 保持高电平，就相当于是把矩阵按键的第一行，即 K1～K4 作为 4 个独立按键来处理，然后把这 4 个按键的状态直接送给 LED9～6 这 4 个 LED 小灯，那么当按键按下时，对应按键的输入引脚是 0，对应小灯控制信号也是 0，于是灯就亮了，这说明上述关于按键检测的理论都是可实现的。

绝大多数情况下，按键是不会一直按住的，所以我们通常检测按键的动作并不是检测一个固定的电平值，而是检测电平值的变化，即按键在按下和弹起这两种状态之间的变化，只要发生了这种变化就说明现在按键产生动作了。

程序上，我们可以把每次扫描到的按键状态都保存起来，当一次按键状态扫描进来的时候，与前一次的状态做比较，如果发现这两次按键状态不一致，就说明按键产生动作了。当上一次的状态是未按下而现在是按下，此时按键的动作就是“按下”；当上一次的状态是按下而现在是未按下，此时按键的动作就是“弹起”。显然，每次按键动作都会包含一次“按下”和一次“弹起”，我们可以任选其一来执行程序，或者两个都用，以执行不同的程序也是可以的。下面就用程序来实现这个功能，程序只取按键 K4 为例。

```
#include <reg52.h>
sbit ADDR0 = P1⁰;
sbit ADDR1 = P1¹;
sbit ADDR2 = P1²;
sbit ADDR3 = P1³;
sbit ENLED = P1⁴;
sbit KEY1 = P2⁴;
sbit KEY2 = P2⁵;
sbit KEY3 = P2⁶;
sbit KEY4 = P2⁷;

unsigned char code LedChar[] = {  //数码管显示字符转换表
    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
};

void main(){
    bit backup = 1;  //定义一个位变量，保存前一次扫描的按键值
    unsigned char cnt = 0;  //定义一个计数变量，记录按键按下的次数
    ENLED = 0;  //选择数码管 DS1 进行显示
    ADDR3 = 1;
    ADDR2 = 0;
    ADDR1 = 0;
    ADDR0 = 0;
    P2 = 0xF7;  //P2.3 置 0，即 KeyOut1 输出低电平
    P0 = LedChar[cnt];  //显示按键次数初值

    while (1){
        //当前值与前次值不相等说明此时按键有动作
        if (KEY4 != backup){
            //如果前次值为 0，则说明当前是由 0 变 1，即按键弹起
            if (backup == 0){
                cnt++;  //按键次数+1
                //只用 1 个数码管显示，所以加到 10 就清零重新开始
                if (cnt >= 10){
                   cnt = 0;
                }
                P0 = LedChar[cnt]; //计数值显示到数码管上
            }
            backup = KEY4;  //更新备份为当前值，以备进行下次比较
        }
    }
}
```

先来介绍出现在程序中的一个新知识点，就是变量类型——bit，这个在标准 C 语言里边是没有的。51 单片机有一种特殊的变量类型就是 bit 型。比如 unsigned char 型是定义了一个无符号的 8 位的数据，它占用一个字节(Byte)的内存，而 bit 型是 1 位数据，只占用 1 个位(bit)的内存，用法和标准 C 中其他的基本数据类型是一致的。它的优点就是节省内存空间，8 个 bit 型变量才相当于 1 个 char 型变量所占用的空间。虽然它只有 0 和 1 两个值，但也已经可以表示很多东西了，比如：按键的按下和弹起、LED 灯的亮和灭、三极管的导通与关断等等，联想一下已经学过的内容，它是不是能用最小的内存代价来完成很多工作呢？

在这个程序中，我们以 K4 为例，按一次按键，就会产生“按下”和“弹起”两个动态的动作，我们选择在“弹起”时对数码管进行加 1 操作。理论是如此，大家可以在板子上用 K4 按键做做实验试试，多按几次，是不是会发生这样一种现象：有的时候我明明只按了一下按键，但数字却加了不止 1，而是 2 或者更多？但是我们的程序并没有任何逻辑上的错误，这是怎么回事呢？于是我们就得来说说按键抖动和消抖的问题了。