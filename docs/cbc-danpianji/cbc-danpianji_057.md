# C 语言函数的调用

在一个程序的编写过程中，随着代码量的增加，如果把所有的语句都写到 main 函数中，一方面程序会显得的比较乱，另外一个方面，当同一个功能需要在不同地方执行时，我们就得再重复写一遍相同的语句。此时，如果把一些零碎的功能单独写成一个函数，在需要它们时只需进行一些简单的函数调用，这样既有助于程序结构的清晰条理，又可以避免大块的代码重复。

在实际工程项目中，一个程序通常都是由很多个子程序模块组成的，一个模块实现一个特定的功能，在 C 语言中，这个模块就用函数来表示。一个 C 程序一般由一个主函数和若干个其他函数构成。主函数可以调用其它函数，其它函数也可以相互调用，但其它函数不能调用主函数。在我们的 51 单片机程序中，还有中断服务函数，是当相应的中断到来后自动调用的，不需要也不能由其它函数来调用。

函数调用的一般形式是：

    函数名 (实参列表);

函数名就是需要调用的函数的名称，实参列表就是根据实际需求调用函数要传递给被调用函数的参数列表，不需要传递参数时只保留括号就可以了，传递多个参数时参数之间要用逗号隔开。

那么我先举例看一下函数调用使程序结构更加条理清晰方面的作用。回顾一下图 6-1 所示的程序流程图和为实现它而编写的程序代码，相对来说这个主函数的结构就比较复杂了，

很难一眼看清楚它的执行流程。那么如果我们把其中最重要的两件事——秒计数和数码管动态扫描功能都用单独的函数来实现会怎样呢？来看程序。

```
#include <reg52.h>

sbit ADDR0 = P1⁰;
sbit ADDR1 = P1¹;
sbit ADDR2 = P1²;
sbit ADDR3 = P1³;
sbit ENLED = P1⁴;

unsigned char code LedChar[] = {  //数码管显示字符转换表
    0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8,
    0x80, 0x90, 0x88, 0x83, 0xC6, 0xA1, 0x86, 0x8E
};
unsigned char LedBuff[6] = {  //数码管显示缓冲区，初值 0xFF 确保启动时都不亮
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

void SecondCount();
void LedRefresh();

void main(){
    ENLED = 0;  //使能 U3，选择控制数码管
    ADDR3 = 1;  //因为需要动态改变 ADDR0-2 的值，所以不需要再初始化了
    TMOD = 0x01;  //设置 T0 为模式 1
    TH0 = 0xFC;  //为 T0 赋初值 0xFC67，定时 1ms
    TL0 = 0x67;
    TR0 = 1;  //启动 T0
    while (1){
        if (TF0 == 1){  //判断 T0 是否溢出
            TF0 = 0;  //T0 溢出后，清零中断标志
            TH0 = 0xFC;  //并重新赋初值
            TL0 = 0x67;
            SecondCount();  //调用秒计数函数
            LedRefresh();  //调用显示刷新函数
        }
    }
}
/* 秒计数函数，每秒进行一次秒数+1，并转换为数码管显示字符 */
void SecondCount(){
    static unsigned int cnt = 0;  //记录 T0 中断次数
    static unsigned long sec = 0;  //记录经过的秒数
    cnt++;  //计数值自加 1
    if (cnt >= 1000){  //判断 T0 溢出是否达到 1000 次
        cnt = 0;  //达到 1000 次后计数值清零
        sec++;  //秒计数自加 1

        LedBuff[0] = LedChar[sec%10];
        LedBuff[1] = LedChar[sec/10%10];
        LedBuff[2] = LedChar[sec/100%10];
        LedBuff[3] = LedChar[sec/1000%10];
        LedBuff[4] = LedChar[sec/10000%10];
        LedBuff[5] = LedChar[sec/100000%10];
    }
}
/* 数码管动态扫描刷新函数 */
void LedRefresh(){
    static unsigned char i = 0; //动态扫描的索引

    switch (i){
        case 0: ADDR2=0; ADDR1=0; ADDR0=0; i++; P0=LedBuff[0]; break;
        case 1: ADDR2=0; ADDR1=0; ADDR0=1; i++; P0=LedBuff[1]; break;
        case 2: ADDR2=0; ADDR1=1; ADDR0=0; i++; P0=LedBuff[2]; break;
        case 3: ADDR2=0; ADDR1=1; ADDR0=1; i++; P0=LedBuff[3]; break;
        case 4: ADDR2=1; ADDR1=0; ADDR0=0; i++; P0=LedBuff[4]; break;
        case 5: ADDR2=1; ADDR1=0; ADDR0=1; i=0; P0=LedBuff[5]; break;
        default: break;
    }
}
```

看一下，主函数的结构是不是清晰的多了——每隔 1ms 就去干两件事，至于这两件事是什么交由各自的函数去实现。还请大家注意一点：原来程序中的 i、cnt、sec 这三个变量在放到单独的函数中后，都加了 static 关键字而变成了静态变量。因为原来的 main()永远不会结束所以它们的值也总是得到保持的，但现在它们在各自的功能函数内，如不加 static 修饰那么每次函数被调用时它们的值就都成了初值了，借此也把静态变量再加深一下理解吧。

当然，这是我们刻意把程序功能做了这样的划分，主要目的还是来讲解函数的调用，对于这个程序即使你不划分函数也复杂不到哪里去，但继续学下去你就能领会到划分功能函数的必要了。现在我们还是把注意力放在学习函数调用上，有以下几点需要大家注意：

1) 函数调用的时候，不需要加函数类型。我们在主函数内调用 SecondCount()和 LedRefresh()时都没有加 void。

2) 调用函数与被调用函数的位置关系，C 语言规定：函数在被调用之前，必须先被定义或声明。意思就是说：在一个文件中，一个函数应该先定义，然后才能被调用，也就是调用函数应位于被调用函数的下方。但是作为一种通常的编程规范，我们推荐 main 函数写在最前面（因为它起到提纲挈领的作用），其后再定义各个功能函数，而中断函数则写在文件的最后。那么主函数要调用定义在它之后的函数怎么办呢？我们就在文件开头，所有函数定义之前，开辟一块区域，叫做函数声明区，用来把被调用的函数声明一下，如此，该函数就可以被随意调用了。如上述例程所示。

3) 函数声明的时候必须加函数类型，函数的形式参数，最后加上一个分号表示结束。函数声明行与函数定义行的唯一区别就是最后的分号，其它的都必须保持一致。这点请尤其注意，初学者很容易因粗心大意而搞错分号或是修改了定义行中的形参却忘了修改声明行中的形参，导致程序编译不过。