# python self 用法详解

对于在类体中定义的实例方法，Python 会自动绑定方法的第一个参数（通常建议将该参数命名为 self），第一个参数总是指向调用该方法的对象。根据第一个参数出现位置的不同，第一个参数所绑定的对象略有区别：

*   在构造方法中引用该构造方法正在初始化的对象。
*   在普通实例方法中引用调用该方法的对象。

由于实例方法（包括构造方法）的第一个 self 参数会自动绑定，因此程序在调用普通实例方法、构造方法时不需要为第一个参数传值。

self 参数（自动绑定的第一个参数）最大的作用就是引用当前方法的调用者，比如前面介绍的在构造方法中通过 self 为该对象增加实例变量。也可以在一个实例方法中访问该类的另一个实例方法或变量。假设定义了一个 Dog 类，这个 Dog 对象的 run() 方法需要调用它的 jump() 方法，此时就可通过 self 参数作为 jump() 方法的调用者。

方法的第一个参数所代表的对象是不确定的，但它的类型是确定的，即它所代表的只能是当前类的实例；只有当这个方法被调用时，它所代表的对象才被确定下来谁在调用这个方法，方法的第一个参数就代表谁。

例如定义如下 Dog 类：

```
class Dog:
    # 定义一个 jump()方法
    def jump(self):
        print("正在执行 jump 方法")
    # 定义一个 run()方法，run()方法需要借助 jump()方法
    def run(self):
        # 使用 self 参数引用调用 run()方法的对象
        self.jump()
        print("正在执行 run 方法")
```

上面代码的 run() 方法中的 self 代表该方法的调用者：谁在调用 run() 方法，那么 self 就代表谁。因此该方法表示：当一个 Dog 对象调用 run() 方法时，run() 方法需要依赖它自己的 jump() 方法。

在现实世界里，对象的一个方法依赖另一个方法的情形很常见，例如，吃饭方法依赖拿筷子方法，写程序方法依赖敲键盘方法，这种依赖都是同一个对象的两个方法之间的依赖。

当 Python 对象的一个方法调用另一个方法时，不可以省略 self。也就是说，将上面的 run()方法改为如下形式是不正确的：

```
# 定义一个 run()方法，run()方法需要借助 jump()方法
def run():
    #省略 self，下面代码会报错
    self.jump()
    print("正在执行 run 方法")
```

从 Python 语言的设计来看，Python 的类、对象有点类似于一个命名空间，因此在调用类、对象的方法时，一定要加上“类”或“对象”的形式。如果直接调用某个方法，这种形式属于调用函数。

此外，在构造方法中，self 参数（第一个参数）代表该构造方法正在初始化的对象。例如如下代码：

```
class InConstructor :
    def __init__(self) :
        # 在构造方法里定义一个 foo 变量（局部变量）
        foo = 0
        # 使用 self 代表该构造方法正在初始化的对象
        # 下面的代码将会把该构造方法正在初始化的对象的 foo 实例变量设为 6
        self.foo = 6
# 所有使用 InConstructor 创建的对象的 foo 实例变量将被设为 6
print(InConstructor().foo) # 输出 6
```

在 InConstructor 的构造方法中，self 参数总是引用该构造方法正在初始化的对象。程序中将正在执行初始化的 InConstructor 对象的 foo 实例变量设为 6，这意味着该构造方法返回的所有对象的 foo 实例变量都等于 6。

需要说明的是，自动绑定的 self 参数并不依赖具体的调用方式，不管是以方法调用还是以函数调用的方式执行它，self 参数一样可以自动绑定。例如如下程序：

```
class User:
    def test(self):
        print('self 参数: ', self)

u = User()
# 以方法形式调用 test()方法
u.test() # <__main__.User object at 0x00000000021F8240>
# 将 User 对象的 test 方法赋值给 foo 变量
foo = u.test
# 通过 foo 变量（函数形式）调用 test()方法。
foo() # <__main__.User object at 0x00000000021F8240>
```

上面程序中第 5 行代码以方法形式调用 User 对象的 test() 方法，此时方法调用者当然会自动绑定到方法的第一个参数（self 参数）；程序中第 11 行代码以函数形式调用 User 对象的 test() 方法，看上去此时没有调用者了，但程序依然会把实际调用者绑定到方法的第一个参数，因此输出结果完全相同。

当 self 参数作为对象的默认引用时，程序可以像访问普通变量一样来访问这个 self 参数，甚至可以把 self 参数当成实例方法的返回值。看下面程序：

```
class ReturnSelf :
    def grow(self):
        if hasattr(self, 'age'):
            self.age += 1
        else:
            self.age = 1
        # return self 返回调用该方法的对象
        return self
rs = ReturnSelf()
# 可以连续调用同一个方法
rs.grow().grow().grow()
print("rs 的 age 属性值是:", rs.age)
```

从上面程序中可以看出，如果在某个方法中把 self 参数作为返回值，则可以多次连续调用同一个方法，从而使得代码更加简洁。但是这种把 self 参数作为返回值的方法可能会造成实际意义的模糊，例如上面的 grow 方法用于表示对象的生长，即 age 属性的值加 1，实际上不应该有返回值。

使用 self 参数作为方法的返回值可以让代码更加简洁，但可能造成实际意义的模糊。