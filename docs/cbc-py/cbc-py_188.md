# Python 守护线程及作用（包含 2 种创建方式）

有一种线程，它是在后台运行的，它的任务是为其他线程提供服务，这种线程被称为“后台线程（Daemon Thread）”，又称为“守护线程”或“精灵线程”。Python 解释器的垃圾回收线程就是典型的后台线程。

后台线程有一个特征，如果所有的前台线程都死亡了，那么后台线程会自动死亡。

调用 Thread 对象的 daemon 属性可以将指定线程设置成后台线程。下面程序将指定线程设置成后台线程，可以看到当所有的前台线程都死亡后，后台线程随之死亡。当在整个虚拟机中只剩下后台线程时，程序就没有继续运行的必要了，所以程序也就退出了。

```
import threading

# 定义后台线程的线程执行体与普通线程没有任何区别
def action(max):
    for i in range(max):
        print(threading.current_thread().name + "  " + str(i))
t = threading.Thread(target=action, args=(100,), name='后台线程')
# 将此线程设置成后台线程
# 也可在创建 Thread 对象时通过 daemon 参数将其设为后台线程
t.daemon = True
# 启动后台线程
t.start()
for i in range(10):
    print(threading.current_thread().name + "  " + str(i))
# -----程序执行到此处，前台线程（主线程）结束------
# 后台线程也应该随之结束
```

上面程序中先将 t 线程设置成后台线程（第 10 行代码），然后启动该线程。本来该线程应该执行到 i 等于 99 时才会结束，但在运行程序时不难发现，该后台线程无法运行到 99，因为当主线程也就是程序中唯一的前台线程运行结束后，程序会主动退出，所以后台线程也就被结束了。

从上面的程序可以看出，主线程默认是前台线程，t 线程默认也是前台线程。但并不是所有的线程默认都是前台线程，有些线程默认就是后台线程。前台线程创建的子线程默认是前台线程，后台线程创建的子线程默认是后台线程。

可见，创建后台线程有两种方式：

1.  主动将线程的 daemon 属性设置为 True。
2.  后台线程启动的线程默认是后台线程。

注意，当前台线程死亡后，Python 解释器会通知后台线程死亡，但是从它接收指令到做出响应需要一定的时间。如果要将某个线程设置为后台线程，则必须在该线程启动之前进行设置。也就是说，将 daemon 属性设为 True，必须在 start() 方法调用之前进行，否则会引发 RuntimeError 异常。