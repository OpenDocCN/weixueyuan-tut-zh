# 浅谈 Python 类命名空间

再次重申，Python 的类就像命名空间。Python 程序默认处于全局命名空间内，类体则处于类命名空间内，Python 允许在全局范围内放置可执行代码，当 Python 执行该程序时，这些代码就会获得执行的机会。类似地，Python 同样允许在类范围内放置可执行代码，当 Python 执行该类定义肘，这些代码同样会获得执行的机会。

例如，如下程序测试了类命名空间：

```
class Item:
    # 直接在类空间中放置执行性质代码
    print('正在定义 Item 类')
    for i in range(10):
        if i % 2 == 0 :
            print('偶数:', i)
        else:
            print('奇数:', i)
```

正如从上面代码所看到的，程序直接在 Item 类体中放置普通的输出语句、循环语句、分支语句，这都是合法的。当程序执行 Item 类时，Item 类命名空间中的这些代码都会被执行。

从执行效果来看，这些可执行代码被放在 Python 类命名空间与全局空间并没有太大的区别。确实如此，这是因为程序并没有定义“成员”（变量或函数），这些代码执行之后就完了，不会留下什么。

但下面代码就有区别。下面代码示范了在全局空间和类命名空间内分别定义 lambda 表达式：

```
global_fn = lambda p: print('执行 lambda 表达式，p 参数: ', p)
class Category:
    cate_fn = lambda p: print('执行 lambda 表达式，p 参数: ', p)
# 调用全局范围内的 global_fn，为参数 p 传入参数值
global_fn('fkit')  # ①
c = Category()
# 调用类命名空间内的 cate_fn，Python 自动绑定第一个参数
c.cate_fn()  # ②
```

上面程序分别在全局空间、类命名空间内定义了两个 lambda 表达式，在全局空间内定义的 lambda 表达式就相当于一个普通函数，因此程序使用调用函数的方式来调用该 lambda 表达式，并显式地为第一个参数绑定参数值，如上面程序中 ① 号代码所示。

对于在类命名空间内定义的 lambda 表达式，则相当于在该类命名空间中定义了一个函数，这个函数就变成了实例方法，因此程序必须使用调用方法的方式来调用该 lambda 表达式，Python 同样会为该方法的第二个参数（相当于 self 参数）绑定参数值，如上面程序中 ② 号代码所示。