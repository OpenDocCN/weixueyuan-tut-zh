# Python 变量作用域（入门必读）

在程序中定义一个变量时，这个变量是有作用范围的，变量的作用范围被称为它的作用域。

根据定义变量的位置，变量分为两种：

*   局部变量：在函数中定义的变量，包括参数，都被称为局部变量。
*   全局变量：在函数外面、全局范围内定义的变量，被称为全局变量。

每个函数在执行时，系统都会为该函数分配一块“临时内存空间”，所有的局部变量都被保存在这块临时内存空间内。当函数执行完成后，这块内存空间就被释放了，这些局部变量也就失效了，因此离开函数之后就不能再访问局部变量了。

全局变量意味着它们可以在所有函数内被访问。

不管是在函数的局部范围内还是在全局范围内，都可能存在多个变量，每个变量“持有”该变量的值。从这个角度来看，不管是局部范围还是全局范围，这些变量和它们的值就像一个“看不见”的字典，其中变量名就是字典的 key，变量值就是字典的 value。

实际上，Python 提供了如下三个工具函数来获取指定范围内的“变量字典”：

1.  globals()：该函数返回全局范围内所有变量组成的“变量字典”。
2.  locals()：该函数返回当前局部范围内所有变量组成的“变量字典”。
3.  vars(object)：获取在指定对象范围内所有变量组成的“变量字典”。如果不传入 object 参数，vars() 和 locals() 的作用完全相同。

globals() 和 locals() 看似完全不同，但它们实际上也是有联系的，关于这两个函数的区别和联系大致有以下两点：

*   locals() 总是获取当前局部范围内所有变量组成的“变量字典”，因此，如果在全局范围内（在函数之外）调用 locals() 函数，同样会获取全局范围内所有变量组成的“变量字典”；而 globals() 无论在哪里执行，总是获取全局范围内所有变量组成的“变量字典”。
*   一般来说，使用 locals() 和 globals() 获取的“变量字典”只应该被访问，不应该被修改。但实际上，不管是使用 globals() 还是使用 locals() 获取的全局范围内的“变量字典”，都可以被修改，而这种修改会真正改变全局变量本身：但通过 locals() 获取的局部范围内的“变量字典”，即使对它修改也不会影响局部变量。

下面程序示范了如何使用 locals()、globals() 函数访问局部范围和全局范围内的“变量字典”：

```
def test ():
    age = 20
    # 直接访问 age 局部变量
    print(age) # 输出 20
    # 访问函数局部范围的“变量数组”
    print(locals()) # {'age': 20}
    # 通过函数局部范围的“变量数组”访问 age 变量
    print(locals()['age']) # 20
    # 通过 locals 函数局部范围的“变量数组”改变 age 变量的值
    locals()['age'] = 12
    # 再次访问 age 变量的值
    print('xxx', age) # 依然输出 20
    # 通过 globals 函数修改 x 全局变量
    globals()['x'] = 19
x = 5
y = 20
print(globals()) # {..., 'x': 5, 'y': 20}
# 在全局访问内使用 locals 函数，访问的是全局变量的“变量数组”
print(locals()) # {..., 'x': 5, 'y': 20}
# 直接访问 x 全局变量
print(x) # 5
# 通过全局变量的“变量数组”访问 x 全局变量
print(globals()['x']) # 5
# 通过全局变量的“变量数组”对 x 全局变量赋值
globals()['x'] = 39
print(x) # 输出 39
# 在全局范围内使用 locals 函数对 x 全局变量赋值
locals()['x'] = 99
print(x) # 输出 99
```

从上面程序可以清楚地看出，locals() 函数用于访问特定范围内的所有变量组成的“变量字典”，而 globals() 函数则用于访问全局范围内的全局变量组成的“变量字典”。

在使用 globals() 或 locals() 访问全局变量的“变量字典”时，将会看到程序输出的“变量字典”默认包含了很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。

全局变量默认可以在所有函数内被访问，但如果在函数中定义了与全局变量同名的变量，此时就会发生局部变量遮蔽（hide）全局变量的情形。例如如下程序：

```
name = 'Charlie'
def test ():
    # 直接访问 name 全局变量
    print(name) # Charlie
test()
print(name)
```

上面程序中，第 4 行直接访问 name 变量，这是允许的，此时程序将会输出 Charlie。如果在此之后增加如下一行代码：

name = '孙悟空'

再次运行该程序，将会看到如下错误：

UnboundLocalError : local variable ‘name’ referenced before assignment

该错误提示粗体字代码所访问的 name 变量还未定义。这是什么原因呢？这正是由于程序在 test() 函数中增加了“name='孙悟空'”一行代码造成的。

Python 语法规定，在函数内部对不存在的变量赋值时，默认就是重新定义新的局部变量。因此这行代码相当于重新定义了 name 局部变量，这样 name 全局变量就被遮蔽了，所以程序会报错。

为了避免这个问题，可以通过以下两种方式来修改上面程序：

1.  访问被遮蔽的全局变量。如果希望程序依然能访问 name 全局变量，且在函数中可重新定义 name 局部变量，也就是在函数中可以访问被遮蔽的全局变量，此时可通过 globals() 函数来实现，将上面程序改为如下形式即可：

    ```
    name = 'Charlie'
    def test ():
        # 直接访问 name 全局变量
        print(globals()['name'])  # Charlie
        name = '孙悟空'
    test()
    print(name)  # Charlie
    ```

2.  在函数中声明全局变量。为了避免在函数中对全局变量赋值（不是重新定义局部变量），可使用 global 语句来声明全局变量。因此，可将程序改为如下形式：

    ```
    name = 'Charlie'
    def test ():
        # 声明 name 是全局变量，后面的赋值语句不会重新定义局部变量
        global name
        # 直接访问 name 全局变量
        print(name)  # Charlie
        name = '孙悟空'
    test()
    print(name)  # 孙悟空
    ```

    增加了“global name”声明之后，程序会把 name 变量当成全局变量，这意味着 test() 函数后面对 name 赋值的语句只是对全局变量赋值，而不是重新定义局部变量。