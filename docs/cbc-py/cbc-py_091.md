# Python __del__ 方法：销毁对象

与 init() 方法对应的是 __del__() 方法，__init__() 方法用于初始化 Python 对象，而 __del__() 则用于销毁 Python 对象，即在任何 Python 对象将要被系统回收之时，系统都会自动调用该对象的 __del__() 方法。

当程序不再需要一个 Python 对象时，系统必须把该对象所占用的内存空间释放出来，这个过程被称为垃圾回收（GC，Garbage Collector），Python 会自动回收所有对象所占用的内存空间，因此开发者无须关心对象垃圾回收的过程。

Python 采用自动引用计数（ARC）方式来回收对象所占用的空间，当程序中有一个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 1；当程序中有两个变量引用该 Python 对象时，Python 会自动保证该对象引用计数为 2，依此类推，如果一个对象的引用计数变成了 0，则说明程序中不再有变量引用该对象，表明程序不再需要该对象，因此 Python 就会回收该对象。

大部分时候，Python 的 ARC 都能准确、高效地回收系统中的每个对象。但如果系统中出现循环引用的情况，比如对象 a 持有一个实例变量引用对象 b，而对象 b 又持有一个实例变量引用对象 a，此时两个对象的引用计数都是 1，而实际上程序已经不再有变量引用它们，系统应该回收它们，此时 Python 的垃圾回收器就可能没那么快，要等专门的循环垃圾回收器（Cyclic Garbage Collector）来检测并回收这种引用循环。

当一个对象被垃圾回收时，Python 就会自动调用该对象的 __del__ 方法。需要说明的是，不要以为对一个变量执行 del 操作，该变量所引用的对象就会被回收，只有当对象的引用计数变成 0 时，该对象才会被回收。因此，如果一个对象有多个变量引用它，那么 del 其中一个变量是不会回收该对象的。

```
class Item:
    def __init__ (self, name, price):
        self.name = name
        self.price = price
    # 定义析构函数
    def __del__ (self):
        print('del 删除对象')
# 创建一个 Item 对象，将之赋给 im 变量
im = Item('鼠标', 29.8)
x = im   # ①
# 打印 im 所引用的 Item 对象
del im
print('--------------')
```

程序中重写了 Item 类的 __del__() 方法，该方法就是 Item 类的析构函数，当系统将要回收 Item 时，系统会自动调用 Item 对象的 __del__() 方法。

上面程序先创建了一个 Item 对象，并将该对象赋值给 im 变量，① 号代码又将 im 赋值给变量 x，这样程序中有两个变量引用 Item 对象，接下来程序执行 del im 代码删除 im 对象，此时由于还有变量引用该 Item 对象，因此程序并不会回收 Item 对象。

运行上面程序，可以看到如下输出结果：

--------------
del 删除对象

从上面程序的输出结果可以看到，del im 执行之后，程序并没有回收 Item 对象，只有等到程序执行将要结束时（系统必须回收所有对象），系统才会回收 Item 对象。

如果将程序中 ① 号代码注释掉，再次运行上面程序，将会看到如下输出结果：

del 删除对象
--------------

注释掉 ① 号代码之后，当程序执行 del im 之后，此时程序中不再有任何变量引用该 Item 对象，因此系统会立即回收该对象，则无须等到程序结束之前。
最后需要说明的是，如果父类提供了 __del__() 方法，则系统重写 __del__() 方法时必须显式调用父类的 __del__() 方法，这样才能保证合理地回收父类实例的部分属性。